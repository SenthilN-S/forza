<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Velocity Forza: Time Trial</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; -webkit-user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI OVERLAY */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        /* HUD */
        #hud { padding: 20px; display: flex; justify-content: space-between; align-items: flex-start; color: white; text-shadow: 0 2px 4px rgba(0,0,0,0.8); display: none; }
        .hud-box { background: rgba(0,0,0,0.5); padding: 10px 20px; border-radius: 8px; border-left: 4px solid #ff3333; transform: skewX(-10deg); }
        .hud-value { font-size: 32px; font-weight: bold; font-family: monospace; }
        .hud-label { font-size: 12px; opacity: 0.8; text-transform: uppercase; }
        
        #center-message { position: absolute; top: 30%; width: 100%; text-align: center; font-size: 80px; font-weight: 900; color: #fff; text-shadow: 0 4px 10px rgba(0,0,0,0.8); font-style: italic; opacity: 0; transition: opacity 0.2s; pointer-events: none; }

        /* MENUS */
        .menu-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; pointer-events: auto; z-index: 100; backdrop-filter: blur(5px); }
        .hidden { display: none !important; }
        
        h1 { font-size: 60px; color: #ff3333; margin: 0 0 10px 0; text-transform: uppercase; font-style: italic; letter-spacing: -2px; text-shadow: 0 0 20px rgba(255, 51, 51, 0.5); text-align: center;}
        h2 { color: white; margin-bottom: 40px; font-weight: 300; }
        
        button { background: linear-gradient(45deg, #ff3333, #cc0000); color: white; border: none; padding: 15px 50px; font-size: 24px; font-weight: bold; text-transform: uppercase; cursor: pointer; transform: skewX(-10deg); transition: transform 0.2s, box-shadow 0.2s; margin: 10px; box-shadow: 0 4px 15px rgba(255, 51, 51, 0.3); }
        button:hover { transform: skewX(-10deg) scale(1.05); box-shadow: 0 6px 20px rgba(255, 51, 51, 0.6); }
        button:active { transform: skewX(-10deg) scale(0.95); }
        
        .stat-row { display: flex; gap: 40px; margin-bottom: 30px; text-align: center; }
        .stat-item h3 { margin: 0; font-size: 40px; color: #fff; }
        .stat-item p { margin: 0; color: #aaa; font-size: 14px; text-transform: uppercase; }

        /* MOBILE CONTROLS */
        #mobile-controls { position: absolute; bottom: 20px; width: 100%; height: 150px; pointer-events: none; display: none; padding: 0 20px; box-sizing: border-box; }
        .touch-btn { pointer-events: auto; background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255,255,255,0.5); border-radius: 15px; backdrop-filter: blur(4px); }
        .touch-btn:active { background: rgba(255, 51, 51, 0.5); border-color: #ff3333; }
        
        .pedal-group { position: absolute; right: 40px; bottom: 10px; display: flex; gap: 15px; }
        .steer-group { position: absolute; left: 40px; bottom: 10px; display: flex; gap: 15px; }
        
        #btn-gas { width: 70px; height: 120px; border-radius: 10px 10px 30px 10px; }
        #btn-brake { width: 60px; height: 80px; margin-top: 40px; border-radius: 10px 10px 10px 10px; }
        #btn-left, #btn-right { width: 80px; height: 80px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 30px; color: white; margin-top: 40px; }

        /* LOADING */
        #loading { position: absolute; bottom: 20px; right: 20px; color: white; font-family: monospace; }
        
    </style>
    <!-- Import Maps for Three.js and Cannon-es -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="hud">
            <div class="hud-box">
                <div class="hud-value" id="timer">00:00.00</div>
                <div class="hud-label">Time</div>
            </div>
            <div id="center-message">3</div>
            <div class="hud-box" style="text-align: right;">
                <div class="hud-value"><span id="speed">0</span> <span style="font-size:16px;">KM/H</span></div>
                <div class="hud-label">Speed</div>
            </div>
        </div>

        <div id="mobile-controls">
            <div class="steer-group">
                <div id="btn-left" class="touch-btn">◄</div>
                <div id="btn-right" class="touch-btn">►</div>
            </div>
            <div class="pedal-group">
                <div id="btn-brake" class="touch-btn"></div>
                <div id="btn-gas" class="touch-btn"></div>
            </div>
        </div>
    </div>

    <!-- MAIN MENU -->
    <div id="main-menu" class="menu-screen">
        <h1>Velocity Forza</h1>
        <h2>High Performance Time Trial</h2>
        <button id="start-btn">Start Race</button>
        <p style="color:#666; font-size: 12px; margin-top:20px;">PC: WASD / Arrows | Mobile: Touch</p>
    </div>

    <!-- FINISH SCREEN -->
    <div id="finish-screen" class="menu-screen hidden">
        <h1>Finish!</h1>
        <div class="stat-row">
            <div class="stat-item">
                <h3 id="finish-time">00:00.00</h3>
                <p>Your Time</p>
            </div>
            <div class="stat-item">
                <h3 id="best-time">--:--.--</h3>
                <p>Best Time</p>
            </div>
        </div>
        <button id="restart-btn">Race Again</button>
        <button id="menu-btn" style="background: #333; font-size: 18px;">Main Menu</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer;
        let world;
        let clock, deltaTime;
        let gameState = 'menu'; // menu, countdown, playing, finished
        
        // Physics Objects
        let vehicle;
        let chassisBody;
        let wheelBodies = [];
        let visualWheels = [];
        let chassisMesh;
        
        // Game Logic
        let startTime = 0;
        let finishTime = 0;
        let bestTime = localStorage.getItem('forzaBestTime') || Infinity;
        let speed = 0;
        
        // Input
        const input = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            brake: false,
            reset: false
        };

        // Audio
        let audioCtx;
        let engineOsc;
        let engineGain;
        let isAudioInit = false;

        // Constants
        const TIME_STEP = 1 / 60;
        const CAM_OFFSET = new THREE.Vector3(0, 2.5, -5.5); // Behind car
        const CAM_LOOK = new THREE.Vector3(0, 1.0, 5); // Look ahead

        // Elements
        const elTimer = document.getElementById('timer');
        const elSpeed = document.getElementById('speed');
        const elMessage = document.getElementById('center-message');
        const elMainMenu = document.getElementById('main-menu');
        const elFinishScreen = document.getElementById('finish-screen');
        const elHud = document.getElementById('hud');
        const elMobile = document.getElementById('mobile-controls');

        // --- INIT ---
        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            // NEW: Sky Blue Background
            const skyColor = 0x87CEEB;
            scene.background = new THREE.Color(skyColor);
            scene.fog = new THREE.FogExp2(skyColor, 0.003);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, -10);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
            scene.add(ambientLight);

            // NEW: Sun Light
            const dirLight = new THREE.DirectionalLight(0xffffee, 1.8);
            dirLight.position.set(100, 150, -50);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -80;
            dirLight.shadow.camera.right = 80;
            dirLight.shadow.camera.top = 80;
            dirLight.shadow.camera.bottom = -80;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.bias = -0.001;
            scene.add(dirLight);

            // NEW: Sun Visual Mesh
            const sunGeo = new THREE.SphereGeometry(15, 16, 16);
            const sunMat = new THREE.MeshBasicMaterial({color: 0xffaa00});
            const sunMesh = new THREE.Mesh(sunGeo, sunMat);
            sunMesh.position.copy(dirLight.position);
            scene.add(sunMesh);

            // Physics World
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.SAPBroadphase(world);
            
            // Materials
            const groundMaterial = new CANNON.Material('ground');
            const wheelMaterial = new CANNON.Material('wheel');
            const chassisMaterial = new CANNON.Material('chassis'); 

            const wheelGroundContact = new CANNON.ContactMaterial(wheelMaterial, groundMaterial, {
                friction: 0.8, // Grip
                restitution: 0,
                contactEquationStiffness: 1000
            });
            world.addContactMaterial(wheelGroundContact);
            
            // Slippery chassis to prevent sticking if it bottoms out
            const chassisGroundContact = new CANNON.ContactMaterial(chassisMaterial, groundMaterial, {
                friction: 0.1, 
                restitution: 0
            });
            world.addContactMaterial(chassisGroundContact);

            // Build Game Objects
            buildTrack(groundMaterial);
            buildCar(wheelMaterial, chassisMaterial);
            
            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            setupInputs();
            
            // Show Best Time
            if(bestTime !== Infinity) {
                document.getElementById('best-time').innerText = formatTime(bestTime);
            }

            // Detect Mobile
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                elMobile.style.display = 'block';
            }

            // Start Loop
            clock = new THREE.Clock();
            requestAnimationFrame(animate);
        }

        // --- PHYSICS & CAR SETUP ---
        function buildCar(wheelMat, chassisMat) {
            // Chassis Physics
            const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.5, 2.2)); // Half extents
            chassisBody = new CANNON.Body({ mass: 1200, material: chassisMat }); // 1200kg sports car
            chassisBody.addShape(chassisShape, new CANNON.Vec3(0, 0.2, 0)); // Offset center of mass slightly down
            chassisBody.position.set(0, 2, 0); // Start position
            chassisBody.angularDamping = 0.5;
            
            // Visual Chassis
            const carGroup = new THREE.Group();
            
            // Main body
            const bodyGeo = new THREE.BoxGeometry(2, 1.0, 4.4);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xcc0000, metalness: 0.6, roughness: 0.2 });
            const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
            bodyMesh.position.y = 0.2;
            bodyMesh.castShadow = true;
            bodyMesh.receiveShadow = true;
            carGroup.add(bodyMesh);

            // Cabin
            const cabinGeo = new THREE.BoxGeometry(1.8, 0.6, 2.2);
            const cabinMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.9, roughness: 0.1 });
            const cabinMesh = new THREE.Mesh(cabinGeo, cabinMat);
            cabinMesh.position.set(0, 0.8, -0.2);
            carGroup.add(cabinMesh);
            
            // Spoiler
            const spoilerGeo = new THREE.BoxGeometry(2.2, 0.1, 0.5);
            const spoilerMesh = new THREE.Mesh(spoilerGeo, bodyMat);
            spoilerMesh.position.set(0, 0.8, -2.1);
            carGroup.add(spoilerMesh);

            chassisMesh = carGroup;
            scene.add(chassisMesh);
            
            // Add to World (Critical)
            world.addBody(chassisBody);

            // Vehicle Setup
            vehicle = new CANNON.RaycastVehicle({
                chassisBody: chassisBody,
                indexRightAxis: 0,
                indexUpAxis: 1, // Y is Up
                indexForwardAxis: 2 // Z is Forward
            });

            const wheelOptions = {
                radius: 0.4,
                directionLocal: new CANNON.Vec3(0, -1, 0),
                suspensionStiffness: 45,
                suspensionRestLength: 0.4,
                frictionSlip: 2.5,
                dampingRelaxation: 2.3,
                dampingCompression: 4.5,
                maxSuspensionForce: 200000,
                rollInfluence: 0.01,
                axleLocal: new CANNON.Vec3(1, 0, 0),
                chassisConnectionPointLocal: new CANNON.Vec3(1, 1, 0),
                maxSuspensionTravel: 0.2,
                customSlidingRotationalSpeed: -30,
                useCustomSlidingRotationalSpeed: true
            };

            // Wheel Positions
            const axleWidth = 0.9;
            const frontAxleZ = 1.3;
            const rearAxleZ = -1.3;
            const height = -0.2;

            // Front Left (0)
            wheelOptions.chassisConnectionPointLocal.set(axleWidth, height, frontAxleZ);
            vehicle.addWheel(wheelOptions);
            // Front Right (1)
            wheelOptions.chassisConnectionPointLocal.set(-axleWidth, height, frontAxleZ);
            vehicle.addWheel(wheelOptions);
            // Rear Left (2)
            wheelOptions.chassisConnectionPointLocal.set(axleWidth, height, rearAxleZ);
            vehicle.addWheel(wheelOptions);
            // Rear Right (3)
            wheelOptions.chassisConnectionPointLocal.set(-axleWidth, height, rearAxleZ);
            vehicle.addWheel(wheelOptions);

            vehicle.addToWorld(world);

            // Wheel Bodies (Visuals)
            const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.4, 24);
            wheelGeo.rotateZ(Math.PI / 2);
            const wheelMeshMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
            
            // Rims
            const rimGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.41, 12);
            rimGeo.rotateZ(Math.PI / 2);
            const rimMat = new THREE.MeshStandardMaterial({color: 0xdddddd, metalness: 0.8});

            for (let i = 0; i < vehicle.wheelInfos.length; i++) {
                const wheelGroup = new THREE.Group();
                const tire = new THREE.Mesh(wheelGeo, wheelMeshMat);
                const rim = new THREE.Mesh(rimGeo, rimMat);
                tire.castShadow = true;
                wheelGroup.add(tire);
                wheelGroup.add(rim);
                
                scene.add(wheelGroup);
                visualWheels.push(wheelGroup);
            }
        }

        // --- TRACK GENERATION ---
        function buildTrack(mat) {
            // Simple winding track logic
            const points = [
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, 80),
                new THREE.Vector3(-40, 0, 140),
                new THREE.Vector3(-100, 0, 140),
                new THREE.Vector3(-150, 0, 80),
                new THREE.Vector3(-150, 0, -50),
                new THREE.Vector3(-50, 0, -100),
                new THREE.Vector3(50, 0, -100),
                new THREE.Vector3(100, 0, -50),
                new THREE.Vector3(100, 0, 50),
                new THREE.Vector3(50, 0, 150),
                new THREE.Vector3(50, 4, 250), // Slight elevation
                new THREE.Vector3(0, 0, 350)   // Finish area
            ];

            const curve = new THREE.CatmullRomCurve3(points);
            const trackGeo = new THREE.TubeGeometry(curve, 100, 12, 4, false); // 12 unit width
            const trackMat = new THREE.MeshStandardMaterial({ 
                color: 0x333333, 
                side: THREE.DoubleSide,
                roughness: 0.9
            });
            const trackMesh = new THREE.Mesh(trackGeo, trackMat);
            trackMesh.receiveShadow = true;
            // Flatten track slightly (Tube is round) - scaling Y down
            trackMesh.scale.set(1, 0.05, 1); 
            // Position adjustment to prevent Z-fighting with floor
            trackMesh.position.y = 0.1;
            scene.add(trackMesh);

            // Physics Floor
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0, material: mat });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
            world.addBody(groundBody);

            // Visual Ground (Grass)
            const grassGeo = new THREE.PlaneGeometry(1000, 1000);
            const grassMat = new THREE.MeshStandardMaterial({ color: 0x336600, roughness: 1 });
            const grass = new THREE.Mesh(grassGeo, grassMat);
            grass.rotation.x = -Math.PI / 2;
            grass.receiveShadow = true;
            scene.add(grass);
            
            // Start Line
            createArch(0, 0, 10, 0x00ff00, "START");
            
            // Finish Line
            createArch(0, 0, 340, 0xff0000, "FINISH");
            
            // Obstacles
            for(let i=0; i<15; i++) {
                createCone(
                    (Math.random() * 100 - 50), 
                    (Math.random() * 200 - 50)
                );
            }

            // NEW: Add Trees
            buildTrees(curve);
        }

        function buildTrees(curve) {
            const trunkGeo = new THREE.CylinderGeometry(0.5, 0.8, 2, 5);
            const trunkMat = new THREE.MeshStandardMaterial({color: 0x5C4033}); // Brown
            const leavesGeo = new THREE.ConeGeometry(3, 7, 6);
            const leavesMat = new THREE.MeshStandardMaterial({color: 0x228b22}); // Forest Green

            const checkPoints = curve.getSpacedPoints(100);

            // Simple loop to scatter trees
            for(let i=0; i<400; i++) {
                const x = (Math.random() * 500) - 250;
                const z = (Math.random() * 600) - 150;
                const pos = new THREE.Vector3(x, 0, z);

                // Check distance to track (Simple collision avoidance)
                let tooClose = false;
                for(let j=0; j<checkPoints.length; j++) {
                    if(pos.distanceTo(checkPoints[j]) < 15) {
                        tooClose = true;
                        break;
                    }
                }

                if(!tooClose) {
                    const tree = new THREE.Group();
                    
                    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                    trunk.position.y = 1;
                    trunk.castShadow = true;
                    trunk.receiveShadow = true;
                    
                    const leaves = new THREE.Mesh(leavesGeo, leavesMat);
                    leaves.position.y = 4.5;
                    leaves.castShadow = true;
                    leaves.receiveShadow = true;

                    tree.add(trunk);
                    tree.add(leaves);
                    tree.position.copy(pos);
                    
                    // Random scale
                    const s = 0.8 + Math.random() * 0.6;
                    tree.scale.set(s,s,s);
                    
                    scene.add(tree);
                }
            }
        }
        
        function createArch(x, y, z, color, text) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            
            const legGeo = new THREE.BoxGeometry(1, 8, 1);
            const mat = new THREE.MeshStandardMaterial({color: 0x444444});
            const legL = new THREE.Mesh(legGeo, mat);
            legL.position.set(-6, 4, 0);
            const legR = new THREE.Mesh(legGeo, mat);
            legR.position.set(6, 4, 0);
            
            const topGeo = new THREE.BoxGeometry(14, 2, 2);
            const topMat = new THREE.MeshStandardMaterial({color: color});
            const top = new THREE.Mesh(topGeo, topMat);
            top.position.set(0, 8, 0);
            
            group.add(legL, legR, top);
            scene.add(group);
        }
        
        function createCone(x, z) {
            // Visual
            const geo = new THREE.ConeGeometry(0.3, 0.8, 16);
            const mat = new THREE.MeshStandardMaterial({color: 0xffaa00});
            const mesh = new THREE.Mesh(geo, mat);
            mesh.castShadow = true;
            mesh.position.set(x, 0.4, z);
            scene.add(mesh);
            
            // Physical
            const shape = new CANNON.Cylinder(0.1, 0.3, 0.8, 8);
            const body = new CANNON.Body({mass: 5});
            body.addShape(shape);
            body.position.set(x, 0.4, z);
            world.addBody(body);
        }

        // --- AUDIO SYSTEM ---
        function initAudio() {
            if(isAudioInit) return;
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
            
            // Engine Oscillator
            engineOsc = audioCtx.createOscillator();
            engineOsc.type = 'sawtooth';
            engineOsc.frequency.value = 100;
            
            // Gain Node
            engineGain = audioCtx.createGain();
            engineGain.gain.value = 0.1;
            
            // Filter to muffle sound
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 400;
            
            engineOsc.connect(filter);
            filter.connect(engineGain);
            engineGain.connect(audioCtx.destination);
            
            engineOsc.start();
            isAudioInit = true;
        }

        function updateAudio(rpm) {
            if(!isAudioInit) return;
            // Map speed/RPM to pitch
            // Base pitch 100Hz, max 400Hz
            const pitch = 80 + (Math.abs(rpm) * 5); 
            engineOsc.frequency.linearRampToValueAtTime(pitch, audioCtx.currentTime + 0.1);
        }

        // --- INPUT HANDLING ---
        function setupInputs() {
            document.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case 'w': case 'ArrowUp': input.forward = true; break;
                    case 's': case 'ArrowDown': input.backward = true; break;
                    case 'a': case 'ArrowLeft': input.left = true; break;
                    case 'd': case 'ArrowRight': input.right = true; break;
                    case ' ': input.brake = true; break;
                }
            });
            document.addEventListener('keyup', (e) => {
                switch(e.key) {
                    case 'w': case 'ArrowUp': input.forward = false; break;
                    case 's': case 'ArrowDown': input.backward = false; break;
                    case 'a': case 'ArrowLeft': input.left = false; break;
                    case 'd': case 'ArrowRight': input.right = false; break;
                    case ' ': input.brake = false; break;
                }
            });

            // Touch
            const bindTouch = (id, key, val) => {
                const el = document.getElementById(id);
                el.addEventListener('touchstart', (e) => { e.preventDefault(); input[key] = val; });
                el.addEventListener('touchend', (e) => { e.preventDefault(); input[key] = false; });
            };
            
            bindTouch('btn-gas', 'forward', true);
            bindTouch('btn-brake', 'backward', true); // Brake/Reverse
            bindTouch('btn-left', 'left', true);
            bindTouch('btn-right', 'right', true);

            // UI Buttons
            document.getElementById('start-btn').addEventListener('click', startGame);
            document.getElementById('restart-btn').addEventListener('click', startGame);
            document.getElementById('menu-btn').addEventListener('click', () => {
                elFinishScreen.classList.add('hidden');
                elMainMenu.classList.remove('hidden');
                gameState = 'menu';
                // Reset car
                resetCar();
                moveCameraMenu();
            });
        }

        // --- GAME LOGIC ---
        function startGame() {
            initAudio();
            if(audioCtx.state === 'suspended') audioCtx.resume();
            
            elMainMenu.classList.add('hidden');
            elFinishScreen.classList.add('hidden');
            elHud.style.display = 'flex';
            
            resetCar();
            
            gameState = 'countdown';
            startCountdown();
        }
        
        function resetCar() {
            chassisBody.position.set(0, 2, 0);
            chassisBody.quaternion.set(0, 0, 0, 1);
            chassisBody.velocity.set(0,0,0);
            chassisBody.angularVelocity.set(0,0,0);
        }
        
        function startCountdown() {
            let count = 3;
            elMessage.style.opacity = 1;
            elMessage.innerText = count;
            
            const intv = setInterval(() => {
                count--;
                if(count > 0) {
                    elMessage.innerText = count;
                } else if (count === 0) {
                    elMessage.innerText = "GO!";
                    gameState = 'playing';
                    startTime = Date.now();
                } else {
                    elMessage.style.opacity = 0;
                    clearInterval(intv);
                }
            }, 1000);
        }
        
        function finishRace() {
            if(gameState !== 'playing') return;
            gameState = 'finished';
            finishTime = Date.now() - startTime;
            
            elHud.style.display = 'none';
            elFinishScreen.classList.remove('hidden');
            
            const timeStr = formatTime(finishTime);
            document.getElementById('finish-time').innerText = timeStr;
            
            if(finishTime < bestTime) {
                bestTime = finishTime;
                localStorage.setItem('forzaBestTime', bestTime);
                document.getElementById('best-time').innerText = timeStr + " (NEW!)";
            } else {
                document.getElementById('best-time').innerText = formatTime(bestTime);
            }
        }
        
        function formatTime(ms) {
            if(ms === Infinity) return "--:--.--";
            const mins = Math.floor(ms / 60000);
            const secs = Math.floor((ms % 60000) / 1000);
            const mills = Math.floor((ms % 1000) / 10);
            return `${pad(mins)}:${pad(secs)}.${pad(mills)}`;
        }
        
        function pad(n) { return n < 10 ? '0'+n : n; }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- MAIN LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // Update Physics
            if (gameState === 'playing' || gameState === 'countdown') {
                world.step(TIME_STEP);
                
                // Update Visuals
                chassisMesh.position.copy(chassisBody.position);
                chassisMesh.quaternion.copy(chassisBody.quaternion);
                
                for (let i = 0; i < vehicle.wheelInfos.length; i++) {
                    vehicle.updateWheelTransform(i);
                    const t = vehicle.wheelInfos[i].worldTransform;
                    visualWheels[i].position.copy(t.position);
                    visualWheels[i].quaternion.copy(t.quaternion);
                }
                
                // Camera Chase
                const relativeCameraOffset = CAM_OFFSET.clone().applyMatrix4(chassisMesh.matrixWorld);
                camera.position.lerp(relativeCameraOffset, 0.1);
                
                const lookAtTarget = CAM_LOOK.clone().applyMatrix4(chassisMesh.matrixWorld);
                camera.lookAt(lookAtTarget);

                // Car Controls
                handleInput();
                
                // Game Checks
                // Speed calc (m/s to km/h)
                speed = chassisBody.velocity.length() * 3.6;
                elSpeed.innerText = Math.floor(speed);
                updateAudio(speed);
                
                if(gameState === 'playing') {
                    const elapsed = Date.now() - startTime;
                    elTimer.innerText = formatTime(elapsed);
                    
                    // Check Finish (Simple distance check to finish line Z)
                    // Track finishes at Z=350 approx
                    if (chassisBody.position.z > 340 && Math.abs(chassisBody.position.x) < 15) {
                        finishRace();
                    }
                    
                    // Reset if fell off world
                    if(chassisBody.position.y < -10) {
                        // Respawn back a bit? For now just reset to start
                        // Ideally checkpoint system, but let's just reset position to last stable Z
                        chassisBody.position.y = 2;
                        chassisBody.velocity.set(0,0,0);
                        chassisBody.angularVelocity.set(0,0,0);
                        // Penalty?
                    }
                }
            } else if (gameState === 'menu' || gameState === 'finished') {
                // Idle Camera Animation
                const t = Date.now() * 0.0005;
                camera.position.set(Math.sin(t)*15, 5, Math.cos(t)*15);
                camera.lookAt(0, 0, 0);
            }

            renderer.render(scene, camera);
        }

        function handleInput() {
            if(gameState !== 'playing') {
                 vehicle.setBrake(10, 0); vehicle.setBrake(10, 1);
                 vehicle.setBrake(10, 2); vehicle.setBrake(10, 3);
                 return;
            }

            const maxSteerVal = 0.5;
            const maxForce = 4000; // Increased force for better acceleration
            const brakeForce = 30;

            // Steer
            let targetSteer = 0;
            if (input.left) targetSteer = maxSteerVal;
            if (input.right) targetSteer = -maxSteerVal;
            
            // Speed sensitive steering
            const steerSpeedFactor = Math.min(1.0, speed / 200); // Reduce steer at high speed
            // vehicle.setSteeringValue(targetSteer * (1 - steerSpeedFactor * 0.5), 0);
            // vehicle.setSteeringValue(targetSteer * (1 - steerSpeedFactor * 0.5), 1);
            
            // Simple Lerp for steering smoothness
            const currentSteer = vehicle.wheelInfos[0].steering;
            const smoothSteer = currentSteer + (targetSteer - currentSteer) * 0.1;
            
            vehicle.setSteeringValue(smoothSteer, 0);
            vehicle.setSteeringValue(smoothSteer, 1);

            // Engine
            let engineForce = 0;
            let brake = 0;

            if (input.forward) {
                engineForce = -maxForce;
            } else if (input.backward) {
                // If moving forward, brake. If stopped, reverse.
                if (speed > 1) brake = brakeForce;
                else engineForce = maxForce / 2;
            }

            if (input.brake) {
                brake = brakeForce * 2; // Handbrake
            }

            vehicle.applyEngineForce(engineForce, 2); // RWD
            vehicle.applyEngineForce(engineForce, 3);

            vehicle.setBrake(brake, 0);
            vehicle.setBrake(brake, 1);
            vehicle.setBrake(brake, 2);
            vehicle.setBrake(brake, 3);
        }
        
        function moveCameraMenu() {
            // Helper to reset cam state if needed
        }

        // Start
        init();

    </script>
</body>
</html>
